<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory Constellation</title>
  <style>
        @import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@300;400;600&family=Playfair+Display:wght@400;600&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
            font-family: 'Cormorant Garamond', serif;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 50%, #2d1b3d 100%);
      position: relative;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .star-field {
      position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        .star {
            position: absolute;
            width: 2px;
            height: 2px;
            background: white;
            border-radius: 50%;
            opacity: 0.6;
            animation: twinkle 3s infinite;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 0.9; transform: scale(1.2); }
        }

        .memory-star {
            position: absolute;
            width: 12px;
            height: 12px;
            cursor: pointer;
            z-index: 10;
            transition: transform 0.3s ease;
        }

        .memory-star::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255, 192, 203, 0.8) 0%, rgba(255, 182, 193, 0.4) 50%, transparent 70%);
            border-radius: 50%;
            filter: blur(3px);
        }

        .memory-star::after {
            content: 'âœ¦';
      position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 220, 230, 0.9);
            font-size: 14px;
            text-shadow: 0 0 8px rgba(255, 192, 203, 0.6);
        }

        .memory-star:hover {
            transform: scale(1.3);
        }

        .memory-star.revealed {
            cursor: default;
            animation: gentleGlow 2s ease-in-out infinite;
        }

        .memory-star.revealed::after {
            color: rgba(255, 240, 245, 1);
            text-shadow: 0 0 12px rgba(255, 192, 203, 0.8);
        }

        @keyframes gentleGlow {
            0%, 100% { 
                transform: scale(1.2);
                filter: brightness(1);
            }
            50% { 
                transform: scale(1.3);
                filter: brightness(1.3);
            }
        }

        .memory-star.expanding {
            animation: expandStar 0.6s ease-out forwards;
        }

        @keyframes expandStar {
            0% { transform: scale(1); }
            50% { transform: scale(2.5); }
            100% { transform: scale(1.2); }
        }

        .message-bubble {
      position: absolute;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 12px 18px;
            color: rgba(255, 240, 245, 0.95);
            font-size: 16px;
            font-weight: 300;
            white-space: nowrap;
      opacity: 0;
            transform: translateY(10px);
      pointer-events: none;
            z-index: 15;
            animation: fadeInBubble 0.5s ease-out 0.3s forwards;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

        @keyframes fadeInBubble {
            to {
      opacity: 1;
                transform: translateY(0);
            }
        }

        .counter {
            position: absolute;
            top: 30px;
            right: 30px;
            color: rgba(255, 240, 245, 0.7);
            font-size: 18px;
            font-weight: 300;
            z-index: 20;
            letter-spacing: 1px;
        }

        .ending-overlay {
      position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0);
            z-index: 25;
            pointer-events: none;
            transition: background 2s ease;
        }

        .ending-overlay.active {
            background: rgba(0, 0, 0, 0.4);
        }

        .ending-text {
      position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Playfair Display', serif;
            font-size: 64px;
            color: rgba(255, 240, 245, 0);
            font-weight: 400;
            letter-spacing: 4px;
            z-index: 26;
            text-shadow: 0 0 20px rgba(255, 192, 203, 0.3);
            transition: color 2s ease, opacity 2s ease;
        }

        .ending-text.active {
            color: rgba(255, 240, 245, 0.95);
            opacity: 1;
        }

        .particle {
      position: absolute;
            width: 2px;
            height: 2px;
            background: rgba(255, 240, 245, 0.4);
      border-radius: 50%;
      pointer-events: none;
            z-index: 5;
        }

        @media (max-width: 768px) {
            .ending-text {
                font-size: 42px;
            }
            
            .message-bubble {
                font-size: 14px;
                padding: 10px 14px;
            }
            
            .counter {
                font-size: 16px;
                top: 20px;
                right: 20px;
            }
    }
  </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="star-field" id="starField"></div>
    <div class="counter" id="counter">Memories Revealed: 0 / 11</div>
    <div class="ending-overlay" id="endingOverlay"></div>
    <div class="ending-text" id="endingText">Happy Valentine's Day</div>

  <script>
        const messages = [
            "Take me back to art cafe",
            "Thank you for planning our San Francisco trip :)",
            "Thanks for being cute.",
            "Your mind is insane!!",
            "Who told you to stop.",
            "I miss you.",
            "Hi handsome.",
            "Please never stop drawing.",
            "Hope I get to see you soon.",
            "Watch movies with me.",
            "Hope we get to eat together again."
        ];

        const memoryStars = [];
        let revealedCount = 0;
        let allRevealed = false;
        let particles = [];
        let animationId = null;

        // Create background stars
        function createBackgroundStars() {
            const starField = document.getElementById('starField');
            const numStars = 150;
            
            for (let i = 0; i < numStars; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.animationDelay = Math.random() * 3 + 's';
                star.style.animationDuration = (Math.random() * 2 + 2) + 's';
                starField.appendChild(star);
            }
        }

        // Check if a position overlaps with existing stars or their message areas
        function checkOverlap(newX, newY, existingStars, minDistance = 200) {
            for (const starData of existingStars) {
                const dx = newX - starData.x;
                const dy = newY - starData.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Check distance to star
                if (distance < minDistance) {
                    return true;
                }
                
                // Check distance to potential message bubble area (above the star)
                const bubbleY = starData.y - 80; // Message appears ~50px above, with some padding
                const bubbleDy = newY - bubbleY;
                const bubbleDistance = Math.sqrt(dx * dx + bubbleDy * bubbleDy);
                
                if (bubbleDistance < minDistance) {
                    return true;
                }
            }
            return false;
        }

        // Create memory stars at random positions
        function createMemoryStars() {
            const container = document.body;
            const padding = 150;
            const minDistance = 220; // Minimum distance between stars and their message areas
            const maxAttempts = 100;
            
            messages.forEach((message, index) => {
                const star = document.createElement('div');
                star.className = 'memory-star';
                star.dataset.message = message;
                star.dataset.index = index;
                
                // Find a position that doesn't overlap
                let x, y;
                let attempts = 0;
                do {
                    x = padding + Math.random() * (window.innerWidth - padding * 2);
                    y = padding + Math.random() * (window.innerHeight - padding * 2);
                    attempts++;
                } while (checkOverlap(x, y, memoryStars, minDistance) && attempts < maxAttempts);
                
                star.style.left = x + 'px';
                star.style.top = y + 'px';
                
                container.appendChild(star);
                memoryStars.push({
                    element: star,
                    x: x,
                    y: y,
                    revealed: false,
                    message: message,
                    targetX: x,
                    targetY: y
                });
                
                star.addEventListener('click', () => revealStar(index));
            });
        }

        // Reveal a star
        function revealStar(index) {
            const starData = memoryStars[index];
            if (starData.revealed || allRevealed) return;
            
            starData.revealed = true;
            const star = starData.element;
            star.classList.add('expanding');
            
            setTimeout(() => {
                star.classList.remove('expanding');
                star.classList.add('revealed');
            }, 600);
            
            // Show message bubble
            setTimeout(() => {
                const bubble = document.createElement('div');
                bubble.className = 'message-bubble';
                bubble.textContent = starData.message;
                
                const rect = star.getBoundingClientRect();
                bubble.style.left = (rect.left + rect.width / 2) + 'px';
                bubble.style.top = (rect.top - 50) + 'px';
                bubble.style.transform = 'translateX(-50%)';
                
                document.body.appendChild(bubble);
                
                // Keep bubble near star
                starData.bubble = bubble;
            }, 300);
            
            revealedCount++;
            document.getElementById('counter').textContent = `Memories Revealed: ${revealedCount} / 11`;
            
            if (revealedCount === 11) {
                setTimeout(() => {
                    startEndingAnimation();
                }, 1000);
            }
        }

        // Calculate heart shape positions
        function getHeartPositions(centerX, centerY, scale = 1) {
            const positions = [];
            const numPoints = 8;
            
            for (let i = 0; i < numPoints; i++) {
                const t = (i / numPoints) * Math.PI * 2;
                let x, y;
                
                // Heart curve formula
                if (i < 4) {
                    // Left side of heart
                    const angle = (i / 4) * Math.PI;
                    x = -16 * Math.pow(Math.sin(angle), 3) * scale;
                    y = -(13 * Math.cos(angle) - 5 * Math.cos(2 * angle) - 2 * Math.cos(3 * angle) - Math.cos(4 * angle)) * scale;
                } else {
                    // Right side of heart
                    const angle = ((i - 4) / 4) * Math.PI;
                    x = 16 * Math.pow(Math.sin(angle), 3) * scale;
                    y = -(13 * Math.cos(angle) - 5 * Math.cos(2 * angle) - 2 * Math.cos(3 * angle) - Math.cos(4 * angle)) * scale;
                }
                
                positions.push({
                    x: centerX + x,
                    y: centerY + y
                });
            }
            
            return positions;
        }

        // Start ending animation
        function startEndingAnimation() {
            allRevealed = true;
            const overlay = document.getElementById('endingOverlay');
            const endingText = document.getElementById('endingText');
            
            overlay.classList.add('active');
            
            // Calculate center position
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            
            // Get heart shape positions
            const heartPositions = getHeartPositions(centerX, centerY, 25);
            
            // Animate stars to heart positions
            memoryStars.forEach((starData, index) => {
                starData.targetX = heartPositions[index].x;
                starData.targetY = heartPositions[index].y;
            });
            
            // Animate stars moving to heart shape
            let startTime = null;
            const duration = 2000;
            
            function animateStars(timestamp) {
                if (!startTime) startTime = timestamp;
                const progress = Math.min((timestamp - startTime) / duration, 1);
                
                // Easing function (ease-in-out)
                const eased = progress < 0.5 
                    ? 2 * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                
                memoryStars.forEach((starData) => {
                    const currentX = starData.x + (starData.targetX - starData.x) * eased;
                    const currentY = starData.y + (starData.targetY - starData.y) * eased;
                    
                    starData.element.style.left = currentX + 'px';
                    starData.element.style.top = currentY + 'px';
                    
                    // Update bubble position if it exists
                    if (starData.bubble) {
                        const rect = starData.element.getBoundingClientRect();
                        starData.bubble.style.left = (rect.left + rect.width / 2) + 'px';
                        starData.bubble.style.top = (rect.top - 50) + 'px';
                    }
                });
                
                if (progress < 1) {
                    animationId = requestAnimationFrame(animateStars);
                } else {
                    // Show ending text
                    setTimeout(() => {
                        endingText.classList.add('active');
                        createParticleField();
                    }, 500);
                }
            }
            
            animationId = requestAnimationFrame(animateStars);
        }

        // Create particle field
        function createParticleField() {
            const numParticles = 50;
            
            for (let i = 0; i < numParticles; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                
                const startX = Math.random() * window.innerWidth;
                const startY = Math.random() * window.innerHeight;
                const vx = (Math.random() - 0.5) * 0.5;
                const vy = (Math.random() - 0.5) * 0.5;
                
                particle.style.left = startX + 'px';
                particle.style.top = startY + 'px';
                
                document.body.appendChild(particle);
                
                particles.push({
                    element: particle,
                    x: startX,
                    y: startY,
                    vx: vx,
                    vy: vy
                });
            }
            
            animateParticles();
        }

        // Animate particles
        function animateParticles() {
            particles.forEach(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                
                // Wrap around edges
                if (particle.x < 0) particle.x = window.innerWidth;
                if (particle.x > window.innerWidth) particle.x = 0;
                if (particle.y < 0) particle.y = window.innerHeight;
                if (particle.y > window.innerHeight) particle.y = 0;
                
                particle.element.style.left = particle.x + 'px';
                particle.element.style.top = particle.y + 'px';
            });
            
            if (allRevealed) {
                requestAnimationFrame(animateParticles);
            }
        }

        // Initialize
        function init() {
            createBackgroundStars();
            createMemoryStars();
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            // Reposition memory stars proportionally
            const scaleX = window.innerWidth / (window.innerWidth || 1);
            const scaleY = window.innerHeight / (window.innerHeight || 1);
            
            memoryStars.forEach(starData => {
                if (!starData.revealed || !allRevealed) {
                    starData.x *= scaleX;
                    starData.y *= scaleY;
                    starData.element.style.left = starData.x + 'px';
                    starData.element.style.top = starData.y + 'px';
                }
            });
        });

        // Start when page loads
        window.addEventListener('load', init);
  </script>
</body>
</html>